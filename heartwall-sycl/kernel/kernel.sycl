// __global FP* in;
int rot_row;
int rot_col;
int in2_rowlow;
int in2_collow;
int ic;
int jc;
int jp1;
int ja1, ja2;
int ip1;
int ia1, ia2;
int ja, jb;
int ia, ib;
FP s;
int i;
int j;
int row;
int col;
int ori_row;
int ori_col;
int position;
FP sum;
int pos_ori;
FP temp;
FP temp2;
int location;
int cent;
int tMask_row; 
int tMask_col;
FP largest_value_current = 0;
FP largest_value = 0;
int largest_coordinate_current = 0;
int largest_coordinate = 0;
FP fin_max_val = 0;
int fin_max_coo = 0;
int largest_row;
int largest_col;
int offset_row;
int offset_col;
FP mean;
FP mean_sqr;
FP variance;
FP deviation;
int pointer;
int ori_pointer;
int loc_pointer;

// __local FP in_final_sum;
// __local FP in_sqr_final_sum;
// __local FP denomT;

//======================================================================================================================================================150
//  BLOCK/THREAD IDs
//======================================================================================================================================================150

int bx = item.get_group(0);                                // get current horizontal block index (0-n)
int tx = item.get_local_id(0);                                // get current horizontal thread index (0-n)
int ei_new;

//======================================================================================================================================================150
//  UNIQUE STRUCTURE RECONSTRUCTED HERE
//======================================================================================================================================================150

// common
auto d_common_change_d_frame = d_frame;

// offsets for either endo or epi points (separate arrays for endo and epi points)
int d_unique_point_no = bx < common.endoPoints ? bx : bx-common.endoPoints;

auto Row = bx < common.endoPoints ? d_endoRow: d_epiRow;
auto Col = bx < common.endoPoints ? d_endoCol: d_epiCol;
auto tRowLoc = bx < common.endoPoints ? d_tEndoRowLoc: d_tEpiRowLoc;
auto tColLoc = bx < common.endoPoints ? d_tEndoColLoc: d_tEpiColLoc;
auto in = bx < common.endoPoints ?  &d_endoT[d_unique_point_no * common.in_elem] :
                                               &d_epiT[d_unique_point_no * common.in_elem] ;


// offsets for all points (one array for all points)
auto in2 = &d_in2[bx*common.in2_elem];
auto conv = &d_conv[bx*common.conv_elem];
auto in2_pad_cumv = &d_in2_pad_cumv[bx*common.in2_pad_cumv_elem];
auto in2_pad_cumv_sel = &d_in2_pad_cumv_sel[bx*common.in2_pad_cumv_sel_elem];
auto in2_sub_cumh = &d_in2_sub_cumh[bx*common.in2_sub_cumh_elem];
auto in2_sub_cumh_sel = &d_in2_sub_cumh_sel[bx*common.in2_sub_cumh_sel_elem];
auto in2_sub2 = &d_in2_sub2[bx*common.in2_sub2_elem];
auto in2_sqr = &d_in2_sqr[bx*common.in2_sqr_elem];
auto in2_sqr_sub2 = &d_in2_sqr_sub2[bx*common.in2_sqr_sub2_elem];
auto in_sqr = &d_in_sqr[bx*common.in_sqr_elem];
auto tMask = &d_tMask[bx*common.tMask_elem];
auto mask_conv = &d_mask_conv[bx*common.mask_conv_elem];

// used to be local
auto in_mod_temp = &d_in_mod_temp[bx*common.in_elem];
auto in_partial_sum = &d_in_partial_sum[bx*common.in_cols];
auto in_sqr_partial_sum = &d_in_sqr_partial_sum[bx*common.in_sqr_rows];
auto par_max_val = &d_par_max_val[bx*common.mask_conv_rows];
auto par_max_coo = &d_par_max_coo[bx*common.mask_conv_rows];

auto in_final_sum = &d_in_final_sum[bx];
auto in_sqr_final_sum = &d_in_sqr_final_sum[bx];
auto denomT = &d_denomT[bx];

//======================================================================================================================================================150
//  END
//======================================================================================================================================================150

//======================================================================================================================================================150
//  Initialize checksum
//======================================================================================================================================================150
#ifdef TEST_CHECKSUM
if(bx==0 && tx==0){

  for(i=0; i<CHECK; i++){
    d_checksum[i] = 0;
  }

}
#endif
//======================================================================================================================================================150
//  INITIAL COORDINATE AND TEMPLATE UPDATE
//======================================================================================================================================================150

// generate templates based on the first frame only
if(frame_no == 0){

  //====================================================================================================100
  //  UPDATE ROW LOC AND COL LOC
  //====================================================================================================100

  // uptade temporary endo/epi row/col coordinates (in each block corresponding to point, narrow work to one thread)
  ei_new = tx;
  if(ei_new == 0){

    // update temporary row/col coordinates
    pointer = d_unique_point_no*common.no_frames+frame_no;
    tRowLoc[pointer] = Row[d_unique_point_no];
    tColLoc[pointer] = Col[d_unique_point_no];

  }

  //====================================================================================================100
  //  CREATE TEMPLATES
  //====================================================================================================100

  // work
  ei_new = tx;
  while(ei_new < common.in_elem){

    // figure out row/col location in new matrix
    row = (ei_new+1) % common.in_rows - 1;                        // (0-n) row
    col = (ei_new+1) / common.in_rows + 1 - 1;                      // (0-n) column
    if((ei_new+1) % common.in_rows == 0){
      row = common.in_rows - 1;
      col = col-1;
    }

    // figure out row/col location in corresponding new template area in image and give to every thread (get top left corner and progress down and right)
    ori_row = Row[d_unique_point_no] - 25 + row - 1;
    ori_col = Col[d_unique_point_no] - 25 + col - 1;
    ori_pointer = ori_col*common.frame_rows+ori_row;

    // update template
    in[col*common.in_rows+row] = d_common_change_d_frame[ori_pointer];

    // go for second round
    ei_new = ei_new + NUMBER_THREADS;

  }

  //====================================================================================================100
  //  SYNCHRONIZE THREADS
  //====================================================================================================100

  item.barrier();

  //====================================================================================================100
  //  checksum
  //====================================================================================================100
#ifdef TEST_CHECKSUM
  if(bx==0 && tx==0){
    for(i=0; i<common.in_elem; i++){
      d_checksum[0] = d_checksum[0]+in[i];
    }
  }

  //====================================================================================================100
  //  SYNCHRONIZE THREADS
  //====================================================================================================100

  item.barrier();
#endif
  //====================================================================================================100
  //  End
  //====================================================================================================100

}

//======================================================================================================================================================150
//  PROCESS POINTS
//======================================================================================================================================================150

// process points in all frames except for the first one
if(frame_no != 0){

  //====================================================================================================100
  //  Initialize frame-specific variables
  //====================================================================================================100

  //====================================================================================================100
  //  SELECTION
  //====================================================================================================100

  in2_rowlow = Row[d_unique_point_no] - common.sSize;                          // (1 to n+1)
  in2_collow = Col[d_unique_point_no] - common.sSize;

  // work
  ei_new = tx;
  while(ei_new < common.in2_elem){

    // figure out row/col location in new matrix
    row = (ei_new+1) % common.in2_rows - 1;                        // (0-n) row
    col = (ei_new+1) / common.in2_rows + 1 - 1;                      // (0-n) column
    if((ei_new+1) % common.in2_rows == 0){
      row = common.in2_rows - 1;
      col = col-1;
    }

    // figure out corresponding location in old matrix and copy values to new matrix
    ori_row = row + in2_rowlow - 1;
    ori_col = col + in2_collow - 1;
    in2[ei_new] = d_common_change_d_frame[ori_col*common.frame_rows+ori_row];

    // go for second round
    ei_new = ei_new + NUMBER_THREADS;

  }

  //====================================================================================================100
  //  SYNCHRONIZE THREADS
  //====================================================================================================100

  item.barrier();

  //====================================================================================================100
  //  checksum
  //====================================================================================================100
#ifdef TEST_CHECKSUM
  if(bx==0 && tx==0){
    for(i=0; i<common.in2_elem; i++){
      d_checksum[1] = d_checksum[1]+in2[i];
    }
  }

  //====================================================================================================100
  //  SYNCHRONIZE THREADS
  //====================================================================================================100

  item.barrier();
#endif
  //====================================================================================================100
  //  CONVOLUTION
  //====================================================================================================100

  //==================================================50
  //  ROTATION
  //==================================================50

  // work
  ei_new = tx;
  while(ei_new < common.in_elem){
    // while(ei_new < 1){

    // figure out row/col location in padded array
    row = (ei_new+1) % common.in_rows - 1;                        // (0-n) row
    col = (ei_new+1) / common.in_rows + 1 - 1;                      // (0-n) column
    if((ei_new+1) % common.in_rows == 0){
      row = common.in_rows - 1;
      col = col-1;
    }

    // execution
    rot_row = (common.in_rows-1) - row;
    rot_col = (common.in_rows-1) - col;
    in_mod_temp[ei_new] = in[rot_col*common.in_rows+rot_row];

    // go for second round
    ei_new = ei_new + NUMBER_THREADS;

  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();

  //==================================================50
  //  checksum
  //==================================================50
#ifdef TEST_CHECKSUM
  if(bx==0 && tx==0){
    for(i=0; i<common.in_elem; i++){
      d_checksum[2] = d_checksum[2]+in_mod_temp[i];
    }
  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();
#endif
  //==================================================50
  //  ACTUAL CONVOLUTION
  //==================================================50

  // work
  ei_new = tx;
  while(ei_new < common.conv_elem){

    // figure out row/col location in array
    ic = (ei_new+1) % common.conv_rows;                        // (1-n)
    jc = (ei_new+1) / common.conv_rows + 1;                      // (1-n)
    if((ei_new+1) % common.conv_rows == 0){
      ic = common.conv_rows;
      jc = jc-1;
    }

    //
    j = jc + common.joffset;
    jp1 = j + 1;
    if(common.in2_cols < jp1){
      ja1 = jp1 - common.in2_cols;
    }
    else{
      ja1 = 1;
    }
    if(common.in_cols < j){
      ja2 = common.in_cols;
    }
    else{
      ja2 = j;
    }

    i = ic + common.ioffset;
    ip1 = i + 1;

    if(common.in2_rows < ip1){
      ia1 = ip1 - common.in2_rows;
    }
    else{
      ia1 = 1;
    }
    if(common.in_rows < i){
      ia2 = common.in_rows;
    }
    else{
      ia2 = i;
    }

    s = 0;

    for(ja=ja1; ja<=ja2; ja++){
      jb = jp1 - ja;
      for(ia=ia1; ia<=ia2; ia++){
        ib = ip1 - ia;
        s = s + in_mod_temp[common.in_rows*(ja-1)+ia-1] * in2[common.in2_rows*(jb-1)+ib-1];
      }
    }

    //conv[common.conv_rows*(jc-1)+ic-1] = s;
    conv[ei_new] = s;

    // go for second round
    ei_new = ei_new + NUMBER_THREADS;

  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();

  //==================================================50
  //  checksum
  //==================================================50
#ifdef TEST_CHECKSUM
  if(bx==0 && tx==0){
    for(i=0; i<common.conv_elem; i++){
      d_checksum[3] = d_checksum[3]+conv[i];
    }
  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();
#endif
  //==================================================50
  //  End
  //==================================================50

  //====================================================================================================100
  //   CUMULATIVE SUM  (LOCAL)
  //====================================================================================================100

  //==================================================50
  //  PADD ARRAY
  //==================================================50

  // work
  ei_new = tx;
  while(ei_new < common.in2_pad_cumv_elem){

    // figure out row/col location in padded array
    row = (ei_new+1) % common.in2_pad_cumv_rows - 1;                        // (0-n) row
    col = (ei_new+1) / common.in2_pad_cumv_rows + 1 - 1;                      // (0-n) column
    if((ei_new+1) % common.in2_pad_cumv_rows == 0){
      row = common.in2_pad_cumv_rows - 1;
      col = col-1;
    }

    // execution
    if(  row > (common.in2_pad_add_rows-1) &&                            // do if has numbers in original array
        row < (common.in2_pad_add_rows+common.in2_rows) && 
        col > (common.in2_pad_add_cols-1) && 
        col < (common.in2_pad_add_cols+common.in2_cols)){
      ori_row = row - common.in2_pad_add_rows;
      ori_col = col - common.in2_pad_add_cols;
      in2_pad_cumv[ei_new] = in2[ori_col*common.in2_rows+ori_row];
    }
    else{                                      // do if otherwise
      in2_pad_cumv[ei_new] = 0;
    }

    // go for second round
    ei_new = ei_new + NUMBER_THREADS;

  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();

  //==================================================50
  //  checksum
  //==================================================50
#ifdef TEST_CHECKSUM
  if(bx==0 && tx==0){
    for(i=0; i<common.in2_pad_cumv_elem; i++){
      d_checksum[4] = d_checksum[4]+in2_pad_cumv[i];
    }
  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();
#endif
  //==================================================50
  //  VERTICAL CUMULATIVE SUM
  //==================================================50

  //work
  ei_new = tx;
  while(ei_new < common.in2_pad_cumv_cols){

    // figure out column position
    pos_ori = ei_new*common.in2_pad_cumv_rows;

    // variables
    sum = 0;

    // loop through all rows
    for(position = pos_ori; position < pos_ori+common.in2_pad_cumv_rows; position = position + 1){
      in2_pad_cumv[position] = in2_pad_cumv[position] + sum;
      sum = in2_pad_cumv[position];
    }

    // go for second round
    ei_new = ei_new + NUMBER_THREADS;

  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();

  //==================================================50
  //  checksum
  //==================================================50
#ifdef TEST_CHECKSUM
  if(bx==0 && tx==0){
    for(i=0; i<common.in2_pad_cumv_cols; i++){
      d_checksum[5] = d_checksum[5]+in2_pad_cumv[i];
    }
  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();
#endif
  //==================================================50
  //  SELECTION
  //==================================================50

  // work
  ei_new = tx;
  while(ei_new < common.in2_pad_cumv_sel_elem){

    // figure out row/col location in new matrix
    row = (ei_new+1) % common.in2_pad_cumv_sel_rows - 1;                        // (0-n) row
    col = (ei_new+1) / common.in2_pad_cumv_sel_rows + 1 - 1;                      // (0-n) column
    if((ei_new+1) % common.in2_pad_cumv_sel_rows == 0){
      row = common.in2_pad_cumv_sel_rows - 1;
      col = col-1;
    }

    // figure out corresponding location in old matrix and copy values to new matrix
    ori_row = row + common.in2_pad_cumv_sel_rowlow - 1;
    ori_col = col + common.in2_pad_cumv_sel_collow - 1;
    in2_pad_cumv_sel[ei_new] = in2_pad_cumv[ori_col*common.in2_pad_cumv_rows+ori_row];

    // go for second round
    ei_new = ei_new + NUMBER_THREADS;

  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();

  //==================================================50
  //  checksum
  //==================================================50
#ifdef TEST_CHECKSUM
  if(bx==0 && tx==0){
    for(i=0; i<common.in2_pad_cumv_sel_elem; i++){
      d_checksum[6] = d_checksum[6]+in2_pad_cumv_sel[i];
    }
  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();
#endif
  //==================================================50
  //  SELECTION 2
  //==================================================50

  // work
  ei_new = tx;
  while(ei_new < common.in2_sub_cumh_elem){

    // figure out row/col location in new matrix
    row = (ei_new+1) % common.in2_sub_cumh_rows - 1;                        // (0-n) row
    col = (ei_new+1) / common.in2_sub_cumh_rows + 1 - 1;                      // (0-n) column
    if((ei_new+1) % common.in2_sub_cumh_rows == 0){
      row = common.in2_sub_cumh_rows - 1;
      col = col-1;
    }

    // figure out corresponding location in old matrix and copy values to new matrix
    ori_row = row + common.in2_pad_cumv_sel2_rowlow - 1;
    ori_col = col + common.in2_pad_cumv_sel2_collow - 1;
    in2_sub_cumh[ei_new] = in2_pad_cumv[ori_col*common.in2_pad_cumv_rows+ori_row];

    // go for second round
    ei_new = ei_new + NUMBER_THREADS;

  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();

  //==================================================50
  //  checksum
  //==================================================50
#ifdef TEST_CHECKSUM
  if(bx==0 && tx==0){
    for(i=0; i<common.in2_sub_cumh_elem; i++){
      d_checksum[7] = d_checksum[7]+in2_sub_cumh[i];
    }
  }
  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();
#endif

  //==================================================50
  //  SUBTRACTION
  //==================================================50

  // work
  ei_new = tx;
  while(ei_new < common.in2_sub_cumh_elem){

    // subtract
    in2_sub_cumh[ei_new] = in2_pad_cumv_sel[ei_new] - in2_sub_cumh[ei_new];

    // go for second round
    ei_new = ei_new + NUMBER_THREADS;

  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();

  //==================================================50
  //  checksum
  //==================================================50
#ifdef TEST_CHECKSUM
  if(bx==0 && tx==0){
    for(i=0; i<common.in2_sub_cumh_elem; i++){
      d_checksum[8] = d_checksum[8]+in2_sub_cumh[i];
    }
  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();
#endif
  //==================================================50
  //  HORIZONTAL CUMULATIVE SUM
  //==================================================50

  // work
  ei_new = tx;
  while(ei_new < common.in2_sub_cumh_rows){

    // figure out row position
    pos_ori = ei_new;

    // variables
    sum = 0;

    // loop through all rows
    for(position = pos_ori; position < pos_ori+common.in2_sub_cumh_elem; position = position + common.in2_sub_cumh_rows){
      in2_sub_cumh[position] = in2_sub_cumh[position] + sum;
      sum = in2_sub_cumh[position];
    }

    // go for second round
    ei_new = ei_new + NUMBER_THREADS;

  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();

  //==================================================50
  //  checksum
  //==================================================50
#ifdef TEST_CHECKSUM
  if(bx==0 && tx==0){
    for(i=0; i<common.in2_sub_cumh_elem; i++){
      d_checksum[9] = d_checksum[9]+in2_sub_cumh[i];
    }
  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();
#endif
  //==================================================50
  //  SELECTION
  //==================================================50

  // work
  ei_new = tx;
  while(ei_new < common.in2_sub_cumh_sel_elem){

    // figure out row/col location in new matrix
    row = (ei_new+1) % common.in2_sub_cumh_sel_rows - 1;                        // (0-n) row
    col = (ei_new+1) / common.in2_sub_cumh_sel_rows + 1 - 1;                      // (0-n) column
    if((ei_new+1) % common.in2_sub_cumh_sel_rows == 0){
      row = common.in2_sub_cumh_sel_rows - 1;
      col = col - 1;
    }

    // figure out corresponding location in old matrix and copy values to new matrix
    ori_row = row + common.in2_sub_cumh_sel_rowlow - 1;
    ori_col = col + common.in2_sub_cumh_sel_collow - 1;
    in2_sub_cumh_sel[ei_new] = in2_sub_cumh[ori_col*common.in2_sub_cumh_rows+ori_row];

    // go for second round
    ei_new = ei_new + NUMBER_THREADS;

  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();

  //==================================================50
  //  checksum
  //==================================================50
#ifdef TEST_CHECKSUM
  if(bx==0 && tx==0){
    for(i=0; i<common.in2_sub_cumh_sel_elem; i++){
      d_checksum[10] = d_checksum[10]+in2_sub_cumh_sel[i];
    }
  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();
#endif
  //==================================================50
  //  SELECTION 2
  //==================================================50

  // work
  ei_new = tx;
  while(ei_new < common.in2_sub2_elem){

    // figure out row/col location in new matrix
    row = (ei_new+1) % common.in2_sub2_rows - 1;                        // (0-n) row
    col = (ei_new+1) / common.in2_sub2_rows + 1 - 1;                      // (0-n) column
    if((ei_new+1) % common.in2_sub2_rows == 0){
      row = common.in2_sub2_rows - 1;
      col = col-1;
    }

    // figure out corresponding location in old matrix and copy values to new matrix
    ori_row = row + common.in2_sub_cumh_sel2_rowlow - 1;
    ori_col = col + common.in2_sub_cumh_sel2_collow - 1;
    in2_sub2[ei_new] = in2_sub_cumh[ori_col*common.in2_sub_cumh_rows+ori_row];

    // go for second round
    ei_new = ei_new + NUMBER_THREADS;

  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();

  //==================================================50
  //  checksum
  //==================================================50
#ifdef TEST_CHECKSUM
  if(bx==0 && tx==0){
    for(i=0; i<common.in2_sub2_elem; i++){
      d_checksum[11] = d_checksum[11]+in2_sub2[i];
    }
  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();
#endif
  //==================================================50
  //  SUBTRACTION
  //==================================================50

  // work
  ei_new = tx;
  while(ei_new < common.in2_sub2_elem){

    // subtract
    in2_sub2[ei_new] = in2_sub_cumh_sel[ei_new] - in2_sub2[ei_new];

    // go for second round
    ei_new = ei_new + NUMBER_THREADS;

  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();

  //==================================================50
  //  checksum
  //==================================================50
#ifdef TEST_CHECKSUM
  if(bx==0 && tx==0){
    for(i=0; i<common.in2_sub2_elem; i++){
      d_checksum[12] = d_checksum[12]+in2_sub2[i];
    }
  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();
#endif
  //==================================================50
  //  End
  //==================================================50

  //====================================================================================================100
  //  CUMULATIVE SUM 2
  //====================================================================================================100

  //==================================================50
  //  MULTIPLICATION
  //==================================================50

  // work
  ei_new = tx;
  while(ei_new < common.in2_sqr_elem){

    temp = in2[ei_new];
    in2_sqr[ei_new] = temp * temp;

    // go for second round
    ei_new = ei_new + NUMBER_THREADS;

  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();

  //==================================================50
  //  checksum
  //==================================================50
#ifdef TEST_CHECKSUM
  if(bx==0 && tx==0){
    for(i=0; i<common.in2_sqr_elem; i++){
      d_checksum[13] = d_checksum[13]+in2_sqr[i];
    }
  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();
#endif
  //==================================================50
  //  PAD ARRAY, VERTICAL CUMULATIVE SUM
  //==================================================50

  //==================================================50
  //  PAD ARRAY
  //==================================================50

  // work
  ei_new = tx;
  while(ei_new < common.in2_pad_cumv_elem){

    // figure out row/col location in padded array
    row = (ei_new+1) % common.in2_pad_cumv_rows - 1;                        // (0-n) row
    col = (ei_new+1) / common.in2_pad_cumv_rows + 1 - 1;                      // (0-n) column
    if((ei_new+1) % common.in2_pad_cumv_rows == 0){
      row = common.in2_pad_cumv_rows - 1;
      col = col-1;
    }

    // execution
    if(  row > (common.in2_pad_add_rows-1) &&                          // do if has numbers in original array
        row < (common.in2_pad_add_rows+common.in2_sqr_rows) && 
        col > (common.in2_pad_add_cols-1) && 
        col < (common.in2_pad_add_cols+common.in2_sqr_cols)){
      ori_row = row - common.in2_pad_add_rows;
      ori_col = col - common.in2_pad_add_cols;
      in2_pad_cumv[ei_new] = in2_sqr[ori_col*common.in2_sqr_rows+ori_row];
    }
    else{                                              // do if otherwise
      in2_pad_cumv[ei_new] = 0;
    }

    // go for second round
    ei_new = ei_new + NUMBER_THREADS;

  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();

  //==================================================50
  //  checksum
  //==================================================50
#ifdef TEST_CHECKSUM
  if(bx==0 && tx==0){
    for(i=0; i<common.in2_pad_cumv_elem; i++){
      d_checksum[14] = d_checksum[14]+in2_pad_cumv[i];
    }
  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();
#endif
  //==================================================50
  //  VERTICAL CUMULATIVE SUM
  //==================================================50

  //work
  ei_new = tx;
  while(ei_new < common.in2_pad_cumv_cols){

    // figure out column position
    pos_ori = ei_new*common.in2_pad_cumv_rows;

    // variables
    sum = 0;

    // loop through all rows
    for(position = pos_ori; position < pos_ori+common.in2_pad_cumv_rows; position = position + 1){
      in2_pad_cumv[position] = in2_pad_cumv[position] + sum;
      sum = in2_pad_cumv[position];
    }

    // go for second round
    ei_new = ei_new + NUMBER_THREADS;

  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();

  //==================================================50
  //  checksum
  //==================================================50
#ifdef TEST_CHECKSUM
  if(bx==0 && tx==0){
    for(i=0; i<common.in2_pad_cumv_elem; i++){
      d_checksum[15] = d_checksum[15]+in2_pad_cumv[i];
    }
  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();
#endif
  //==================================================50
  //  SELECTION
  //==================================================50

  // work
  ei_new = tx;
  while(ei_new < common.in2_pad_cumv_sel_elem){

    // figure out row/col location in new matrix
    row = (ei_new+1) % common.in2_pad_cumv_sel_rows - 1;                        // (0-n) row
    col = (ei_new+1) / common.in2_pad_cumv_sel_rows + 1 - 1;                      // (0-n) column
    if((ei_new+1) % common.in2_pad_cumv_sel_rows == 0){
      row = common.in2_pad_cumv_sel_rows - 1;
      col = col-1;
    }

    // figure out corresponding location in old matrix and copy values to new matrix
    ori_row = row + common.in2_pad_cumv_sel_rowlow - 1;
    ori_col = col + common.in2_pad_cumv_sel_collow - 1;
    in2_pad_cumv_sel[ei_new] = in2_pad_cumv[ori_col*common.in2_pad_cumv_rows+ori_row];

    // go for second round
    ei_new = ei_new + NUMBER_THREADS;

  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();

  //==================================================50
  //  checksum
  //==================================================50
#ifdef TEST_CHECKSUM
  if(bx==0 && tx==0){
    for(i=0; i<common.in2_pad_cumv_sel_elem; i++){
      d_checksum[16] = d_checksum[16]+in2_pad_cumv_sel[i];
    }
  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();
#endif
  //==================================================50
  //  SELECTION 2
  //==================================================50

  // work
  ei_new = tx;
  while(ei_new < common.in2_sub_cumh_elem){

    // figure out row/col location in new matrix
    row = (ei_new+1) % common.in2_sub_cumh_rows - 1;                        // (0-n) row
    col = (ei_new+1) / common.in2_sub_cumh_rows + 1 - 1;                      // (0-n) column
    if((ei_new+1) % common.in2_sub_cumh_rows == 0){
      row = common.in2_sub_cumh_rows - 1;
      col = col-1;
    }

    // figure out corresponding location in old matrix and copy values to new matrix
    ori_row = row + common.in2_pad_cumv_sel2_rowlow - 1;
    ori_col = col + common.in2_pad_cumv_sel2_collow - 1;
    in2_sub_cumh[ei_new] = in2_pad_cumv[ori_col*common.in2_pad_cumv_rows+ori_row];

    // go for second round
    ei_new = ei_new + NUMBER_THREADS;

  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();

  //==================================================50
  //  checksum
  //==================================================50
#ifdef TEST_CHECKSUM
  if(bx==0 && tx==0){
    for(i=0; i<common.in2_sub_cumh_elem; i++){
      d_checksum[17] = d_checksum[17]+in2_sub_cumh[i];
    }
  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();
#endif
  //==================================================50
  //  SUBTRACTION
  //==================================================50

  // work
  ei_new = tx;
  while(ei_new < common.in2_sub_cumh_elem){

    // subtract
    in2_sub_cumh[ei_new] = in2_pad_cumv_sel[ei_new] - in2_sub_cumh[ei_new];

    // go for second round
    ei_new = ei_new + NUMBER_THREADS;

  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();

  //==================================================50
  //  checksum
  //==================================================50
#ifdef TEST_CHECKSUM
  if(bx==0 && tx==0){
    for(i=0; i<common.in2_sub_cumh_elem; i++){
      d_checksum[18] = d_checksum[18]+in2_sub_cumh[i];
    }
  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();
#endif
  //==================================================50
  //  HORIZONTAL CUMULATIVE SUM
  //==================================================50

  // work
  ei_new = tx;
  while(ei_new < common.in2_sub_cumh_rows){

    // figure out row position
    pos_ori = ei_new;

    // variables
    sum = 0;

    // loop through all rows
    for(position = pos_ori; position < pos_ori+common.in2_sub_cumh_elem; position = position + common.in2_sub_cumh_rows){
      in2_sub_cumh[position] = in2_sub_cumh[position] + sum;
      sum = in2_sub_cumh[position];
    }

    // go for second round
    ei_new = ei_new + NUMBER_THREADS;

  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();

  //==================================================50
  //  checksum
  //==================================================50
#ifdef TEST_CHECKSUM
  if(bx==0 && tx==0){
    for(i=0; i<common.in2_sub_cumh_rows; i++){
      d_checksum[19] = d_checksum[19]+in2_sub_cumh[i];
    }
  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();
#endif
  //==================================================50
  //  SELECTION
  //==================================================50

  // work
  ei_new = tx;
  while(ei_new < common.in2_sub_cumh_sel_elem){

    // figure out row/col location in new matrix
    row = (ei_new+1) % common.in2_sub_cumh_sel_rows - 1;                        // (0-n) row
    col = (ei_new+1) / common.in2_sub_cumh_sel_rows + 1 - 1;                      // (0-n) column
    if((ei_new+1) % common.in2_sub_cumh_sel_rows == 0){
      row = common.in2_sub_cumh_sel_rows - 1;
      col = col - 1;
    }

    // figure out corresponding location in old matrix and copy values to new matrix
    ori_row = row + common.in2_sub_cumh_sel_rowlow - 1;
    ori_col = col + common.in2_sub_cumh_sel_collow - 1;
    in2_sub_cumh_sel[ei_new] = in2_sub_cumh[ori_col*common.in2_sub_cumh_rows+ori_row];

    // go for second round
    ei_new = ei_new + NUMBER_THREADS;

  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();

  //==================================================50
  //  checksum
  //==================================================50
#ifdef TEST_CHECKSUM
  if(bx==0 && tx==0){
    for(i=0; i<common.in2_sub_cumh_sel_elem; i++){
      d_checksum[20] = d_checksum[20]+in2_sub_cumh_sel[i];
    }
  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();
#endif
  //==================================================50
  //  SELECTION 2
  //==================================================50

  // work
  ei_new = tx;
  while(ei_new < common.in2_sub2_elem){

    // figure out row/col location in new matrix
    row = (ei_new+1) % common.in2_sub2_rows - 1;                        // (0-n) row
    col = (ei_new+1) / common.in2_sub2_rows + 1 - 1;                      // (0-n) column
    if((ei_new+1) % common.in2_sub2_rows == 0){
      row = common.in2_sub2_rows - 1;
      col = col-1;
    }

    // figure out corresponding location in old matrix and copy values to new matrix
    ori_row = row + common.in2_sub_cumh_sel2_rowlow - 1;
    ori_col = col + common.in2_sub_cumh_sel2_collow - 1;
    in2_sqr_sub2[ei_new] = in2_sub_cumh[ori_col*common.in2_sub_cumh_rows+ori_row];

    // go for second round
    ei_new = ei_new + NUMBER_THREADS;

  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();

  //==================================================50
  //  checksum
  //==================================================50
#ifdef TEST_CHECKSUM
  if(bx==0 && tx==0){
    for(i=0; i<common.in2_sub2_elem; i++){
      d_checksum[21] = d_checksum[21]+in2_sqr_sub2[i];
    }
  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();
#endif
  //==================================================50
  //  SUBTRACTION
  //==================================================50

  // work
  ei_new = tx;
  while(ei_new < common.in2_sub2_elem){

    // subtract
    in2_sqr_sub2[ei_new] = in2_sub_cumh_sel[ei_new] - in2_sqr_sub2[ei_new];

    // go for second round
    ei_new = ei_new + NUMBER_THREADS;

  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();

  //==================================================50
  //  checksum
  //==================================================50
#ifdef TEST_CHECKSUM
  if(bx==0 && tx==0){
    for(i=0; i<common.in2_sub2_elem; i++){
      d_checksum[22] = d_checksum[22]+in2_sqr_sub2[i];
    }
  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();
#endif
  //==================================================50
  //  End
  //==================================================50

  //====================================================================================================100
  //  FINAL
  //====================================================================================================100

  //==================================================50
  //  DENOMINATOR A    SAVE RESULT IN CUMULATIVE SUM A2
  //==================================================50

  // work
  ei_new = tx;
  while(ei_new < common.in2_sub2_elem){

    temp = in2_sub2[ei_new];
    temp2 = in2_sqr_sub2[ei_new] - (temp * temp / common.in_elem);
    if(temp2 < 0){
      temp2 = 0;
    }
    in2_sqr_sub2[ei_new] = sqrt(temp2);


    // go for second round
    ei_new = ei_new + NUMBER_THREADS;

  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();

  //==================================================50
  //  checksum
  //==================================================50
#ifdef TEST_CHECKSUM
  if(bx==0 && tx==0){
    for(i=0; i<common.in2_sub2_elem; i++){
      d_checksum[23] = d_checksum[23]+in2_sqr_sub2[i];
    }
  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();
#endif
  //==================================================50
  //  MULTIPLICATION
  //==================================================50

  // work
  ei_new = tx;
  while(ei_new < common.in_sqr_elem){

    temp = in[ei_new];
    in_sqr[ei_new] = temp * temp;

    // go for second round
    ei_new = ei_new + NUMBER_THREADS;

  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();

  //==================================================50
  //  checksum
  //==================================================50
#ifdef TEST_CHECKSUM
  if(bx==0 && tx==0){
    for(i=0; i<common.in_sqr_elem; i++){
      d_checksum[24] = d_checksum[24]+in_sqr[i];
    }
  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();
#endif
  //==================================================50
  //  IN SUM
  //==================================================50

  // work
  ei_new = tx;
  while(ei_new < common.in_cols){

    sum = 0;
    for(i = 0; i < common.in_rows; i++){

      sum = sum + in[ei_new*common.in_rows+i];

    }
    in_partial_sum[ei_new] = sum;

    // go for second round
    ei_new = ei_new + NUMBER_THREADS;

  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();

  //==================================================50
  //  checksum
  //==================================================50
#ifdef TEST_CHECKSUM
  if(bx==0 && tx==0){
    for(i=0; i<common.in_cols; i++){
      d_checksum[25] = d_checksum[25]+in_partial_sum[i];
    }
  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();
#endif
  //==================================================50
  //  IN_SQR SUM
  //==================================================50

  ei_new = tx;
  while(ei_new < common.in_sqr_rows){

    sum = 0;
    for(i = 0; i < common.in_sqr_cols; i++){

      sum = sum + in_sqr[ei_new+common.in_sqr_rows*i];

    }
    in_sqr_partial_sum[ei_new] = sum;

    // go for second round
    ei_new = ei_new + NUMBER_THREADS;

  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();

  //==================================================50
  //  checksum
  //==================================================50
#ifdef TEST_CHECKSUM
  if(bx==0 && tx==0){
    for(i=0; i<common.in_sqr_rows; i++){
      d_checksum[26] = d_checksum[26]+in_sqr_partial_sum[i];
    }
  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();
#endif
  //==================================================50
  //  FINAL SUMMATION
  //==================================================50

  if(tx == 0){

    in_final_sum[0] = 0;
    for(i = 0; i<common.in_cols; i++){
      // in_final_sum = in_final_sum + in_partial_sum[i];
      in_final_sum[0] = in_final_sum[0] + in_partial_sum[i];
    }

  }else if(tx == 1){

    in_sqr_final_sum[0] = 0;
    for(i = 0; i<common.in_sqr_cols; i++){
      // in_sqr_final_sum = in_sqr_final_sum + in_sqr_partial_sum[i];
      in_sqr_final_sum[0] = in_sqr_final_sum[0] + in_sqr_partial_sum[i];
    }

  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();

  //==================================================50
  //  checksum
  //==================================================50
#ifdef TEST_CHECKSUM
  if(bx==0 && tx==0){
    d_checksum[27] = d_checksum[27]+in_final_sum[0]+in_sqr_final_sum[0];
  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();
#endif
  //==================================================50
  //  DENOMINATOR T
  //==================================================50

  if(tx == 0){

    // mean = in_final_sum / common.in_elem;                          // gets mean (average) value of element in ROI
    mean = in_final_sum[0] / common.in_elem;                          // gets mean (average) value of element in ROI
    mean_sqr = mean * mean;
    // variance  = (in_sqr_final_sum / common.in_elem) - mean_sqr;              // gets variance of ROI
    variance  = (in_sqr_final_sum[0] / common.in_elem) - mean_sqr;              // gets variance of ROI
    deviation = sqrt(variance);                                // gets standard deviation of ROI

    // denomT = sqrt((float)(common.in_elem-1))*deviation;
    denomT[0] = sqrt((float)(common.in_elem-1))*deviation;

  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();

  //==================================================50
  //  checksum
  //==================================================50
#ifdef TEST_CHECKSUM
  if(bx==0 && tx==0){
    d_checksum[28] = d_checksum[28]+denomT[i];
  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();
#endif
  //==================================================50
  //  DENOMINATOR    SAVE RESULT IN CUMULATIVE SUM A2
  //==================================================50

  // work
  ei_new = tx;
  while(ei_new < common.in2_sub2_elem){

    // in2_sqr_sub2[ei_new] = in2_sqr_sub2[ei_new] * denomT;
    in2_sqr_sub2[ei_new] = in2_sqr_sub2[ei_new] * denomT[0];

    // go for second round
    ei_new = ei_new + NUMBER_THREADS;

  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();

  //==================================================50
  //  checksum
  //==================================================50
#ifdef TEST_CHECKSUM
  if(bx==0 && tx==0){
    for(i=0; i<common.in2_sub2_elem; i++){
      d_checksum[29] = d_checksum[29]+in2_sqr_sub2[i];
    }
  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();
#endif
  //==================================================50
  //  NUMERATOR  SAVE RESULT IN CONVOLUTION
  //==================================================50

  // work
  ei_new = tx;
  while(ei_new < common.conv_elem){

    // conv[ei_new] = conv[ei_new] - in2_sub2[ei_new] * in_final_sum / common.in_elem;
    conv[ei_new] = conv[ei_new] - in2_sub2[ei_new] * in_final_sum[0] / common.in_elem;

    // go for second round
    ei_new = ei_new + NUMBER_THREADS;

  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();

  //==================================================50
  //  checksum
  //==================================================50
#ifdef TEST_CHECKSUM
  if(bx==0 && tx==0){
    for(i=0; i<common.conv_elem; i++){
      d_checksum[30] = d_checksum[30]+conv[i];
    }
  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();
#endif
  //==================================================50
  //  CORRELATION  SAVE RESULT IN CUMULATIVE SUM A2
  //==================================================50

  // work
  ei_new = tx;
  while(ei_new < common.in2_sub2_elem){

    in2_sqr_sub2[ei_new] = conv[ei_new] / in2_sqr_sub2[ei_new];

    // go for second round
    ei_new = ei_new + NUMBER_THREADS;

  }



  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();

  //==================================================50
  //  checksum
  //==================================================50
#ifdef TEST_CHECKSUM
  if(bx==0 && tx==0){
    for(i=0; i<common.in2_sub2_elem; i++){
      d_checksum[31] = d_checksum[31]+in2_sqr_sub2[i];
    }
  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();
#endif
  //==================================================50
  //  End
  //==================================================50

  //====================================================================================================100
  //  TEMPLATE MASK CREATE
  //====================================================================================================100

  cent = common.sSize + common.tSize + 1;
  if(frame_no == 0){
    tMask_row = cent + Row[d_unique_point_no] - Row[d_unique_point_no] - 1;
    tMask_col = cent + Col[d_unique_point_no] - Col[d_unique_point_no] - 1;
  }
  else{
    pointer = d_unique_point_no*common.no_frames+frame_no-1;
    tMask_row = cent + tRowLoc[pointer] - Row[d_unique_point_no] - 1;
    tMask_col = cent + tColLoc[pointer] - Col[d_unique_point_no] - 1;
  }

  //work
  ei_new = tx;
  while(ei_new < common.tMask_elem){

    location = tMask_col*common.tMask_rows + tMask_row;

    if(ei_new==location){
      tMask[ei_new] = 1;
    }
    else{
      tMask[ei_new] = 0;
    }

    //go for second round
    ei_new = ei_new + NUMBER_THREADS;

  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();

  //==================================================50
  //  checksum
  //==================================================50
#ifdef TEST_CHECKSUM
  if(bx==0 && tx==0){
    for(i=0; i<common.tMask_elem; i++){
      d_checksum[32] = d_checksum[32]+tMask[i];
    }
  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();
#endif
  //==================================================50
  //  End
  //==================================================50

  //====================================================================================================100
  //  MASK CONVOLUTION
  //====================================================================================================100

  // work
  ei_new = tx;
  while(ei_new < common.mask_conv_elem){

    // figure out row/col location in array
    ic = (ei_new+1) % common.mask_conv_rows;                        // (1-n)
    jc = (ei_new+1) / common.mask_conv_rows + 1;                      // (1-n)
    if((ei_new+1) % common.mask_conv_rows == 0){
      ic = common.mask_conv_rows;
      jc = jc-1;
    }

    //
    j = jc + common.mask_conv_joffset;
    jp1 = j + 1;
    if(common.mask_cols < jp1){
      ja1 = jp1 - common.mask_cols;
    }
    else{
      ja1 = 1;
    }
    if(common.tMask_cols < j){
      ja2 = common.tMask_cols;
    }
    else{
      ja2 = j;
    }

    i = ic + common.mask_conv_ioffset;
    ip1 = i + 1;

    if(common.mask_rows < ip1){
      ia1 = ip1 - common.mask_rows;
    }
    else{
      ia1 = 1;
    }
    if(common.tMask_rows < i){
      ia2 = common.tMask_rows;
    }
    else{
      ia2 = i;
    }

    s = 0;

    for(ja=ja1; ja<=ja2; ja++){
      jb = jp1 - ja;
      for(ia=ia1; ia<=ia2; ia++){
        ib = ip1 - ia;
        s = s + tMask[common.tMask_rows*(ja-1)+ia-1] * 1;
      }
    }

    // //mask_conv[common.mask_conv_rows*(jc-1)+ic-1] = s;
    mask_conv[ei_new] = in2_sqr_sub2[ei_new] * s;

    // go for second round
    ei_new = ei_new + NUMBER_THREADS;

  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();

  //==================================================50
  //  checksum
  //==================================================50
#ifdef TEST_CHECKSUM
  if(bx==0 && tx==0){
    for(i=0; i<common.mask_conv_elem; i++){
      d_checksum[33] = d_checksum[33]+mask_conv[i];
    }
  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();
#endif
  //==================================================50
  //  End
  //==================================================50

  //====================================================================================================100
  //  MAXIMUM VALUE
  //====================================================================================================100

  //==================================================50
  //  INITIAL SEARCH
  //==================================================50

  ei_new = tx;
  while(ei_new < common.mask_conv_rows){

    for(i=0; i<common.mask_conv_cols; i++){
      largest_coordinate_current = ei_new*common.mask_conv_rows+i;
      largest_value_current = fabs(mask_conv[largest_coordinate_current]);
      if(largest_value_current > largest_value){
        largest_coordinate = largest_coordinate_current;
        largest_value = largest_value_current;
      }
    }
    par_max_coo[ei_new] = largest_coordinate;
    par_max_val[ei_new] = largest_value;

    // go for second round
    ei_new = ei_new + NUMBER_THREADS;

  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();

  //==================================================50
  //  checksum
  //==================================================50
#ifdef TEST_CHECKSUM
  if(bx==0 && tx==0){
    for(i=0; i<common.mask_conv_rows; i++){
      d_checksum[34] = d_checksum[34]+par_max_coo[i]+par_max_val[i];
    }
  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();
#endif
  //==================================================50
  //  FINAL SEARCH
  //==================================================50

  if(tx == 0){

    for(i = 0; i < common.mask_conv_rows; i++){
      if(par_max_val[i] > fin_max_val){
        fin_max_val = par_max_val[i];
        fin_max_coo = par_max_coo[i];
      }
    }

    // convert coordinate to row/col form
    largest_row = (fin_max_coo+1) % common.mask_conv_rows - 1;                      // (0-n) row
    largest_col = (fin_max_coo+1) / common.mask_conv_rows;                        // (0-n) column
    if((fin_max_coo+1) % common.mask_conv_rows == 0){
      largest_row = common.mask_conv_rows - 1;
      largest_col = largest_col - 1;
    }

    // calculate offset
    largest_row = largest_row + 1;                                  // compensate to match MATLAB format (1-n)
    largest_col = largest_col + 1;                                  // compensate to match MATLAB format (1-n)
    offset_row = largest_row - common.in_rows - (common.sSize - common.tSize);
    offset_col = largest_col - common.in_cols - (common.sSize - common.tSize);
    pointer = d_unique_point_no*common.no_frames+frame_no;
    tRowLoc[pointer] = Row[d_unique_point_no] + offset_row;
    tColLoc[pointer] = Col[d_unique_point_no] + offset_col;

  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();

  //==================================================50
  //  checksum
  //==================================================50
#ifdef TEST_CHECKSUM
  if(bx==0 && tx==0){
    d_checksum[35] = d_checksum[35]+tRowLoc[pointer]+tColLoc[pointer];
  }

  //==================================================50
  //  SYNCHRONIZE THREADS
  //==================================================50

  item.barrier();
#endif
  //==================================================50
  //  End
  //==================================================50

  //====================================================================================================100
  //  End
  //====================================================================================================100

  }

  //======================================================================================================================================================150
  //  PERIODIC COORDINATE AND TEMPLATE UPDATE
  //======================================================================================================================================================150

  if(frame_no != 0 && (frame_no)%10 == 0){


    //====================================================================================================100
    // if the last frame in the bath, update template
    //====================================================================================================100

    // update coordinate
    loc_pointer = d_unique_point_no*common.no_frames+frame_no;

    Row[d_unique_point_no] = tRowLoc[loc_pointer];
    Col[d_unique_point_no] = tColLoc[loc_pointer];

    // work
    ei_new = tx;
    while(ei_new < common.in_elem){

      // figure out row/col location in new matrix
      row = (ei_new+1) % common.in_rows - 1;                        // (0-n) row
      col = (ei_new+1) / common.in_rows + 1 - 1;                      // (0-n) column
      if((ei_new+1) % common.in_rows == 0){
        row = common.in_rows - 1;
        col = col-1;
      }

      // figure out row/col location in corresponding new template area in image and give to every thread (get top left corner and progress down and right)
      ori_row = Row[d_unique_point_no] - 25 + row - 1;
      ori_col = Col[d_unique_point_no] - 25 + col - 1;
      ori_pointer = ori_col*common.frame_rows+ori_row;

      // update template
      in[ei_new] = common.alpha*in[ei_new] + (1-common.alpha)*d_common_change_d_frame[ori_pointer];

      // go for second round
      ei_new = ei_new + NUMBER_THREADS;

    }

    //==================================================50
    //  SYNCHRONIZE THREADS
    //==================================================50

    item.barrier();

    //==================================================50
    //  checksum
    //==================================================50
#ifdef TEST_CHECKSUM
    if(bx==0 && tx==0){
      for(i=0; i<common.in_elem; i++){
        d_checksum[36] = d_checksum[36]+in[i];
      }
    }

    //==================================================50
    //  SYNCHRONIZE THREADS
    //==================================================50

    item.barrier();
#endif
    //==================================================50
    //  End
    //==================================================50

    //====================================================================================================100
    //  End
    //====================================================================================================100

  }


